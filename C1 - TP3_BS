import numpy as np
from scipy.stats import norm

class Option:
    def __init__(self, spot, strike, risk_free, time_to_maturity, volatility):
        self.S = spot
        self.K = strike
        self.r = risk_free
        self.T = time_to_maturity
        self.sigma = volatility

    def d1(self):
        return (np.log(self.S / self.K) + (self.r + 0.5 * self.sigma ** 2) * self.T) / (self.sigma * np.sqrt(self.T))

    def d2(self):
        return self.d1() - self.sigma * np.sqrt(self.T)

    # communs Call & Put
    def compute_gamma(self):
        d1 = self.d1()
        return norm.pdf(d1) / (self.S * self.sigma * np.sqrt(self.T))

    def compute_vega(self):
        d1 = self.d1()
        return self.S * norm.pdf(d1) * np.sqrt(self.T)


class Call(Option):
    def compute_price(self):
        d1 = self.d1()
        d2 = self.d2()
        return self.S * norm.cdf(d1) - self.K * np.exp(-self.r * self.T) * norm.cdf(d2)

    def compute_delta(self):
        d1 = self.d1()
        return norm.cdf(d1)

    def compute_theta(self):
        d1 = self.d1()
        d2 = self.d2()
        term1 = -(self.S * norm.pdf(d1) * self.sigma) / (2 * np.sqrt(self.T))
        term2 = -self.r * self.K * np.exp(-self.r * self.T) * norm.cdf(d2)
        return term1 + term2

    def compute_rho(self):
        d2 = self.d2()
        return self.K * self.T * np.exp(-self.r * self.T) * norm.cdf(d2)


class Put(Option):
    def compute_price(self):
        d1 = self.d1()
        d2 = self.d2()
        return self.K * np.exp(-self.r * self.T) * norm.cdf(-d2) - self.S * norm.cdf(-d1)

    def compute_delta(self):
        d1 = self.d1()
        return norm.cdf(d1) - 1

    def compute_theta(self):
        d1 = self.d1()
        d2 = self.d2()
        term1 = -(self.S * norm.pdf(d1) * self.sigma) / (2 * np.sqrt(self.T))
        term2 = self.r * self.K * np.exp(-self.r * self.T) * norm.cdf(-d2)
        return term1 + term2

    def compute_rho(self):
        d2 = self.d2()
        return -self.K * self.T * np.exp(-self.r * self.T) * norm.cdf(-d2)
###########################
#PARTIE II - MONTECARLO
############################   
import numpy as np

class Payoff:
    def __init__(self, strike):
        self.K = strike

    def calculate(self, spot):
        raise NotImplementedError


class PayoffCall(Payoff):
    def calculate(self, spot):
        return np.maximum(spot - self.K, 0.0)


class PayoffPut(Payoff):
    def calculate(self, spot):
        return np.maximum(self.K - spot, 0.0)


class Derivative:
    def __init__(self, spot, risk_free, time_to_maturity, volatility):
        self.spot = spot
        self.risk_free = risk_free
        self.time_to_maturity = time_to_maturity
        self.volatility = volatility

    def price(self, payoff):
        raise NotImplementedError


class EuropeanOption(Derivative):
    def __init__(self, spot, risk_free, time_to_maturity, volatility, payoff):
        super().__init__(spot, risk_free, time_to_maturity, volatility)
        self.payoff = payoff

    def price(self, num_simulations=100000):
        z = np.random.standard_normal(num_simulations)
        ST = self.spot * np.exp(
            (self.risk_free - 0.5 * self.volatility ** 2) * self.time_to_maturity
            + self.volatility * np.sqrt(self.time_to_maturity) * z
        )
        payoff_values = [self.payoff.calculate(s) for s in ST]
        return np.exp(-self.risk_free * self.time_to_maturity) * np.mean(payoff_values)
